\mysection{\FPUChapterName}
\label{sec:FPU}

\newcommand{\FNURLSTACK}{\footnote{\href{http://go.yurichev.com/17123}{wikipedia.org/wiki/Stack\_machine}}}
\newcommand{\FNURLFORTH}{\footnote{\href{http://go.yurichev.com/17124}{wikipedia.org/wiki/Forth\_(programming\_language)}}}
\newcommand{\FNURLIEEE}{\footnote{\href{http://go.yurichev.com/17125}{wikipedia.org/wiki/IEEE\_floating\_point}}}
\newcommand{\FNURLSP}{\footnote{\href{http://go.yurichev.com/17126}{wikipedia.org/wiki/Single-precision\_floating-point\_format}}}
\newcommand{\FNURLDP}{\footnote{\href{http://go.yurichev.com/17127}{wikipedia.org/wiki/Double-precision\_floating-point\_format}}}
\newcommand{\FNURLEP}{\footnote{\href{http://go.yurichev.com/17128}{wikipedia.org/wiki/Extended\_precision}}}

\ac{FPU}はメイン\ac{CPU}内のデバイスで、特に浮動小数点数を扱うように設計されています。

これは過去に\q{コプロセッサー}と呼ばれていましたが、メイン\ac{CPU}とは別の場所にとどまっています。

\subsection{IEEE 754}

IEEE 754形式の数字は、\IT{符号}、\IT{有効数字}（\IT{小数部}とも呼ばれます）、および\IT{指数}で構成されます。

\subsection{x86}

x86の\ac{FPU}を学ぶ前に、スタックマシン\FNURLSTACK を調べたり、Forth言語\FNURLFORTH の基礎を学ぶことは価値があります。

\myindex{Intel!80486}
\myindex{Intel!FPU}
過去（80486 CPUの前）のコプロセッサは別個のチップであり、いつもマザーボードにプリインストールされていなかった
ことは興味深いことです。別に購入してインストールすることができました。
\footnote{たとえば、John Carmackは、32ビット\ac{GPR}レジスタ（整数部分は16ビット、小数部分は16ビット）
に格納されたDoomビデオゲームの固定小数点演算（\href{http://go.yurichev.com/17356}{wikipedia.org/wiki/Fixed-point\_arithmetic}）
の値を使用しました。 DoomはFPUなしの32ビットコンピュータ、つまり80386と80486 SXで動作しました}

\ac{FPU}は80486 DX CPUから\ac{CPU}に統合されています。

\myindex{x86!\Instructions!FWAIT}
\INS{FWAIT}命令は、\ac{CPU}を待機状態に切り替えるので、\ac{FPU}が処理を終了するまで待つことができるという事実を思い出させます。

もう一つの基本は、\ac{FPU}命令オペコードが、いわゆる\q{エスケープ}オペコード（\GTT{D8..DF}）、
すなわちオペコードが別個のコプロセッサに渡されることから始まるという事実です。

\myindex{IEEE 754}
\label{FPU_is_stack}

FPUは8個の80ビットレジスタを保持できるスタックを持ち、各レジスタは
IEEE 754\FNURLIEEE 形式の番号を保持できます。

それらは\ST{0}..\ST{7}です。 簡潔には、 \IDA と \olly は\ST{0}を\GTT{ST}と表示します。
これは一部の教科書とマニュアルでは\q{スタックトップ}として表されています。

\subsection{ARM, MIPS, x86/x64 SIMD}

ARMおよびMIPSでは、FPUはスタックではなく、\ac{GPR}のようにランダムアクセスできるレジスタのセットです。

同じ体系がx86/x64 CPUのSIMD拡張で使用されています。

\subsection{\CCpp}

\myindex{float}
\myindex{double}

標準の \CCpp 言語では、 \Tfloat （\IT{単精度}\FNURLSP、32ビット）と 
\footnote{単精度浮動小数点数形式も 
\IT{\WorkingWithFloatAsWithStructSubSubSectionName}~(\myref{sec:floatasstruct}) セクションで扱います}
\Tdouble （\IT{倍精度}\FNURLDP、64ビット）の少なくとも2つの浮動小数点型が用意されています。

\InSqBrackets{\TAOCPvolII 246}において、\IT{単精度}は、浮動小数点値を単一の[32ビット]マシンに入れることができることを意味するワード、
\IT{倍精度}は、2ワード（64ビット）で格納できることを意味します。

\myindex{long double}

GCCはMSVCがサポートしない\IT{long double}型（\IT{拡張精度}\FNURLEP、80ビット）もサポートしています。

\Tfloat 型は、32ビット環境では \Tint 型と同じビット数が必要ですが、
数値表現はまったく異なります。

\input{patterns/12_FPU/1_simple/main}
\input{patterns/12_FPU/2_passing_floats/main}
\input{patterns/12_FPU/3_comparison/main}

\subsection{Some constants}

It's easy to find representations of some constants in Wikipedia for IEEE 754 encoded numbers.
It's interesting to know that 0.0 in IEEE 754 is represented as 32 zero bits (for single precision) or 64 zero bits
(for double).
So in order to set a floating point variable to 0.0 in register or memory, one can use \MOV or \TT{XOR reg, reg} instruction.
\myindex{\CStandardLibrary!memset()}
This is suitable for structures where many variables present of various data types.
With usual memset() function one can set all integer variables to 0, all boolean variables to \IT{false}, all pointers
to NULL, and all floating point variables (of any precision) to 0.0.

\subsection{Copying}

One may think inertially that \INS{FLD}/\INS{FST} instructions must be used to load and store (and hence, copy) IEEE 754 values.
Nevertheless, same can be achieved easier by usual \INS{MOV} instruction, which, of course, copies values bitwisely.

\subsection{Stack, calculators and reverse Polish notation}

\myindex{Reverse Polish notation}

Now we understand why some old calculators use reverse Polish notation
\footnote{\href{http://go.yurichev.com/17354}{wikipedia.org/wiki/Reverse\_Polish\_notation}}.

For example, for addition of 12 and 34 one has to enter 12, then 34, then press \q{plus} sign.

It's because old calculators were just stack machine implementations, and this was much simpler
than to handle complex parenthesized expressions.

\subsection{80 bits?}

\myindex{Punched card}
Internal numbers representation in FPU --- 80-bit.
Strange number, because the number not in $2^n$ form.
There is a hypothesis that this is probably due to historical reasons---the standard IBM puched card can encode 12 rows of 80 bits.
$80\cdot 25$ text mode resolution was also popular in past.

Wikipedia has another explanation: \url{https://en.wikipedia.org/wiki/Extended_precision}.

If you know better, please a drop email to the author: \EMAIL{}.

\subsection{x64}

On how floating point numbers are processed in x86-64, read more here: \myref{floating_SIMD}.

% sections
\input{patterns/12_FPU/exercises}
